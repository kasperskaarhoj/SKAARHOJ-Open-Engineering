/* -LICENSE-START-
 ** Copyright (c) 2016 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#pragma once

#include <include/BMDSDIControlShield.h>
#include <Arduino.h>
#include <stdint.h>

namespace BMD
{
	class SDICameraControl : public SDIControlShield
	{
	private:
		bool bundleActive;
		bool momentaryOverride = false;
	public:
		/** Camera control setup */
		void		setOverride(bool enabled) const;
		bool 		getOverride() const;
		void 		setMomentaryOverride(bool enabled);

		/** Low level camera control read operations */
		bool		available() const;
		template <unsigned N>
		int			read(byte (&data)[N]) const;
		int			read(byte data[], int dataLength) const;
		void		flushRead() const;

		/** Low level camera control write operations */
		bool		availableForWrite() const;
		template <unsigned N>
		void		write(const byte (&data)[N]) const;
		void		write(const byte data[], int dataLength, bool forceWrite = false) const;
		void		flushWrite() const;

		/** High level camera control write operations */
		void 		writeCommandVoid(byte camera, byte category, byte parameter) const;
		void 		writeCommandBool(byte camera, byte category, byte parameter, byte operation, bool value) const;
		template <unsigned N>
		void 		writeCommandInt8(byte camera, byte category, byte parameter, byte operation, int8_t (&values)[N]) const;
		void		writeCommandInt8(byte camera, byte category, byte parameter, byte operation, int8_t value) const;
		template <unsigned N>
		void 		writeCommandInt16(byte camera, byte category, byte parameter, byte operation, int16_t (&values)[N]) const;
		void		writeCommandInt16(byte camera, byte category, byte parameter, byte operation, int16_t value) const;
		template <unsigned N>
		void 		writeCommandInt32(byte camera, byte category, byte parameter, byte operation, int32_t (&values)[N]) const;
		void		writeCommandInt32(byte camera, byte category, byte parameter, byte operation, int32_t value) const;
		template <unsigned N>
		void 		writeCommandInt64(byte camera, byte category, byte parameter, byte operation, int64_t (&values)[N]) const;
		void		writeCommandInt64(byte camera, byte category, byte parameter, byte operation, int64_t value) const;
		void		writeCommandUTF8(byte camera, byte category, byte parameter, byte operation, const char* string) const;
		void 		writeCommandUTF8(byte camera, byte category, byte parameter, byte operation, const String& string) const;
		template <unsigned N>
		void 		writeCommandFixed16(byte camera, byte category, byte parameter, byte operation, float (&values)[N]) const;
		void		writeCommandFixed16(byte camera, byte category, byte parameter, byte operation, float value) const;

		void startBundle();
		void endBundle();

		/** Format conversion */
		int16_t		toFixed16(float value) const;
		float		fromFixed16(int16_t value) const;

		mutable byte outputBuffer[255];
		mutable uint8_t outputLength;
	};


	template <unsigned N>
	int SDICameraControl::read(byte (&data)[N]) const
	{
		return read(data, N);
	}

	template <unsigned N>
	void SDICameraControl::write(const byte (&data)[N]) const
	{
		write(data, N);
	}

	inline void SDICameraControl::writeCommandInt8(byte camera, byte category, byte parameter, byte operation, int8_t value) const
	{
		int8_t valueArray[] = { value };
		writeCommandInt8(camera, category, parameter, operation, valueArray);
	}

	template <unsigned N>
	void SDICameraControl::writeCommandInt8(byte camera, byte category, byte parameter, byte operation, int8_t (&values)[N]) const
	{
		const uint8_t kHeaderLength  = 4;
		const uint8_t kParamLength   = 1;
		const uint8_t kPayloadLength = 4 + (kParamLength * N);
		const uint8_t kPaddingLength = (kPayloadLength % 4) ? (4 - (kPayloadLength % 4)) : 0;

		byte payload[kHeaderLength + kPayloadLength + kPaddingLength] =
			{
				/* Header */
				camera,         // Destination
				kPayloadLength, // Payload Length
				0,              // Command
				0,              // Source

				/* Payload */
				category,       // Category
				parameter,      // Parameter
				1,              // Data Type
				operation,      // Operation
			};

		for (int i = 0; i < N; i++)
			toLittleEndian<int8_t>((uint8_t*)&payload[kHeaderLength + 4 + (i * kParamLength)], values[i]);

		write(payload);
	}

	template <unsigned N>
	void SDICameraControl::writeCommandInt16(byte camera, byte category, byte parameter, byte operation, int16_t (&values)[N]) const
	{
		const uint8_t kHeaderLength  = 4;
		const uint8_t kParamLength   = 2;
		const uint8_t kPayloadLength = 4 + (kParamLength * N);
		const uint8_t kPaddingLength = (kPayloadLength % 4) ? (4 - (kPayloadLength % 4)) : 0;

		byte payload[kHeaderLength + kPayloadLength + kPaddingLength] =
			{
				/* Header */
				camera,         // Destination
				kPayloadLength, // Payload Length
				0,              // Command
				0,              // Source

				/* Payload */
				category,       // Category
				parameter,      // Parameter
				2,              // Data Type
				operation,      // Operation
			};

		for (int i = 0; i < N; i++)
			toLittleEndian<int16_t>(&payload[kHeaderLength + 4 + (i * kParamLength)], values[i]);

		write(payload);
	}

	inline void SDICameraControl::writeCommandInt16(byte camera, byte category, byte parameter, byte operation, int16_t value) const
	{
		int16_t valueArray[] = { value };
		writeCommandInt16(camera, category, parameter, operation, valueArray);
	}

	template <unsigned N>
	void SDICameraControl::writeCommandInt32(byte camera, byte category, byte parameter, byte operation, int32_t (&values)[N]) const
	{
		const uint8_t kHeaderLength  = 4;
		const uint8_t kParamLength   = 4;
		const uint8_t kPayloadLength = 4 + (kParamLength * N);
		const uint8_t kPaddingLength = (kPayloadLength % 4) ? (4 - (kPayloadLength % 4)) : 0;

		byte payload[kHeaderLength + kPayloadLength + kPaddingLength] =
			{
				/* Header */
				camera,         // Destination
				kPayloadLength, // Payload Length
				0,              // Command
				0,              // Source

				/* Payload */
				category,       // Category
				parameter,      // Parameter
				3,              // Data Type
				operation,      // Operation
			};

		for (int i = 0; i < N; i++)
			toLittleEndian<int32_t>(&payload[kHeaderLength + 4 + (i * kParamLength)], values[i]);

		write(payload);
	}

	inline void SDICameraControl::writeCommandInt32(byte camera, byte category, byte parameter, byte operation, int32_t value) const
	{
		int32_t valueArray[] = { value };
		writeCommandInt32(camera, category, parameter, operation, valueArray);
	}

	template <unsigned N>
	void SDICameraControl::writeCommandInt64(byte camera, byte category, byte parameter, byte operation, int64_t (&values)[N]) const
	{
		const uint8_t kHeaderLength  = 4;
		const uint8_t kParamLength   = 8;
		const uint8_t kPayloadLength = 4 + (kParamLength * N);
		const uint8_t kPaddingLength = (kPayloadLength % 4) ? (4 - (kPayloadLength % 4)) : 0;

		byte payload[kHeaderLength + kPayloadLength + kPaddingLength] =
			{
				/* Header */
				camera,         // Destination
				kPayloadLength, // Payload Length
				0,              // Command
				0,              // Source

				/* Payload */
				category,       // Category
				parameter,      // Parameter
				4,              // Data Type
				operation,      // Operation
			};

		for (int i = 0; i < N; i++)
			toLittleEndian<int64_t>(&payload[kHeaderLength + 4 + (i * kParamLength)], values[i]);

		write(payload);
	}

	inline void SDICameraControl::writeCommandInt64(byte camera, byte category, byte parameter, byte operation, int64_t value) const
	{
		int64_t valueArray[] = { value };
		writeCommandInt64(camera, category, parameter, operation, valueArray);
	}

	inline void SDICameraControl::writeCommandUTF8(byte camera, byte category, byte parameter, byte operation, const String& string) const
	{
		writeCommandUTF8(camera, category, parameter, operation, string.c_str());
	}

	template <unsigned N>
	void SDICameraControl::writeCommandFixed16(byte camera, byte category, byte parameter, byte operation, float (&values)[N]) const
	{
		const uint8_t kHeaderLength  = 4;
		const uint8_t kParamLength   = 2;
		const uint8_t kPayloadLength = 4 + (kParamLength * N);
		const uint8_t kPaddingLength = (kPayloadLength % 4) ? (4 - (kPayloadLength % 4)) : 0;

		byte payload[kHeaderLength + kPayloadLength + kPaddingLength] =
			{
				/* Header */
				camera,         // Destination
				kPayloadLength, // Payload Length
				0,              // Command
				0,              // Source

				/* Payload */
				category,       // Category
				parameter,      // Parameter
				128,            // Data Type
				operation,      // Operation
			};

		for (int i = 0; i < N; i++)
		{
			int16_t value = toFixed16(values[i]);
			toLittleEndian<int16_t>(&payload[kHeaderLength + 4 + (i * kParamLength)], value);
		}

		write(payload);
	}

	inline void SDICameraControl::writeCommandFixed16(byte camera, byte category, byte parameter, byte operation, float value) const
	{
		float valueArray[] = { value };
		writeCommandFixed16(camera, category, parameter, operation, valueArray);
	}

	inline int16_t SDICameraControl::toFixed16(float value) const
	{
		value *= (1 << 11);

		if (value > 32767)
			value = 32767;
		else if (value < -32768)
			value = -32768;

		return value;
	}

	inline float SDICameraControl::fromFixed16(int16_t value) const
	{
		return (float)value / (1 << 11);
	}
}
