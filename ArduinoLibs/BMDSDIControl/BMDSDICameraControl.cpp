/* -LICENSE-START-
 ** Copyright (c) 2016 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include <include/BMDSDICameraControl.h>
#include <include/BMDSDIControlShieldRegisters.h>
#include <string.h>

namespace BMD {
  void SDICameraControl::setOverride(bool enabled) const {
    byte regValue = regRead8(kRegCONTROL);
    if (enabled)
      regValue |= kRegCONTROL_COVERIDE_Mask;
    else
      regValue &= ~kRegCONTROL_COVERIDE_Mask;

    regWrite8(kRegCONTROL, regValue);
  }
  
  bool SDICameraControl::getOverride() const
  {
    byte regValue = regRead8(kRegCONTROL);
    return regValue & kRegCONTROL_COVERIDE_Mask;
  }


  void SDICameraControl::setMomentaryOverride(bool enabled) {
    momentaryOverride = enabled;
  }

  bool SDICameraControl::available() const { return (regRead8(kRegICARM) & kRegOCARM_ARM_Mask) == 0; }

  int SDICameraControl::read(byte data[], int dataLength) const {
    if (!available())
      return 0;

    // Read control data incoming length and data
    int availableLength = regRead16(kRegICLENGTH);

    if (availableLength > dataLength)
      return -1;

    regRead(kRegICDATA, data, availableLength);

    // Arm the control data incoming bank
    regWrite8(kRegICARM, kRegICARM_ARM_Mask);

    return availableLength;
  }

  void SDICameraControl::flushRead() const { regWrite8(kRegICARM, kRegICARM_ARM_Mask); }

  bool SDICameraControl::availableForWrite() const { return (regRead8(kRegOCARM) & kRegOCARM_ARM_Mask) == 0; }

  void SDICameraControl::startBundle() {
    bundleActive = true;
  }

  void SDICameraControl::endBundle() {
    if(outputLength > 0) {
      write(outputBuffer, outputLength, true);
    }
    outputLength = 0;
    bundleActive = false;
  }

  void SDICameraControl::write(const byte data[], int dataLength, bool forceWrite) const {

    if(shieldInitialized) {
      if(!bundleActive || forceWrite) {
        if(momentaryOverride) setOverride(true);
        // Ensure any pending writes are complete before writing new data
        flushWrite();

        // Set up control override length and data
        regWrite8(kRegOCLENGTH, dataLength);
        regWrite(kRegOCDATA, data, dataLength);

        // Arm the control override bank
        regWrite8(kRegOCARM, kRegOCARM_ARM_Mask);
        if(momentaryOverride) setOverride(false);
      } else {
        if(outputLength + dataLength < 255) {
          memcpy(outputBuffer + outputLength, data, dataLength);
          outputLength += dataLength;
        } else {
          write(outputBuffer, outputLength, true);
          outputLength = 0;
        }
      }
    } else {
      memcpy(outputBuffer, data, dataLength);
      outputLength = dataLength;
    }
  }

  void SDICameraControl::flushWrite() const {
    while (!availableForWrite()) {
      // Wait for control override bank to become ready for new data
    }
  }

  void SDICameraControl::writeCommandVoid(byte camera, byte category, byte parameter) const {
    const uint8_t kHeaderLength = 4;
    const uint8_t kParamLength = 1;
    const uint8_t kPayloadLength = 4 + (kParamLength * 1);
    const uint8_t kPaddingLength = (kPayloadLength % 4) ? (4 - (kPayloadLength % 4)) : 0;

    byte payload[kHeaderLength + kPayloadLength + kPaddingLength] = {                    /* Header */
                                                                     camera,             // Destination
                                                                     kPayloadLength - 1, // Payload Length
                                                                     0,                  // Command
                                                                     0,                  // Source

                                                                     /* Payload */
                                                                     category,  // Category
                                                                     parameter, // Parameter
                                                                     0,         // Data Type
                                                                     0,         // Operation

                                                                     1, 0, 0, 0};

    write(payload);
  }

  void SDICameraControl::writeCommandBool(byte camera, byte category, byte parameter, byte operation, bool value) const {
    const uint8_t kHeaderLength = 4;
    const uint8_t kParamLength = 1;
    const uint8_t kPayloadLength = 4 + (kParamLength * 1);
    const uint8_t kPaddingLength = (kPayloadLength % 4) ? (4 - (kPayloadLength % 4)) : 0;

    byte payload[kHeaderLength + kPayloadLength + kPaddingLength] = {                /* Header */
                                                                     camera,         // Destination
                                                                     kPayloadLength, // Payload Length
                                                                     0,              // Command
                                                                     0,              // Source

                                                                     /* Payload */
                                                                     category,  // Category
                                                                     parameter, // Parameter
                                                                     0,         // Data Type
                                                                     operation, // Operation

                                                                     value, 0, 0, 0};

    write(payload);
  }

  void SDICameraControl::writeCommandUTF8(byte camera, byte category, byte parameter, byte operation, const char *string) const {
    const uint8_t kMaxStringLength = 64;

    const uint8_t kHeaderLength = 4;
    const uint8_t kParamLength = min(strlen(string), kMaxStringLength);
    const uint8_t kPayloadLength = 4 + (kParamLength * 1);
    const uint8_t kPaddingLength = (kPayloadLength % 4) ? (4 - (kPayloadLength % 4)) : 0;

    byte payload[kHeaderLength + (4 + kMaxStringLength) + 4] = {
        /* Header */
        camera,         // Destination
        kPayloadLength, // Payload Length
        0,              // Command
        0,              // Source

        /* Payload */
        category,  // Category
        parameter, // Parameter
        5,         // Data Type
        operation, // Operation
    };

    strncpy((char *)&payload[kHeaderLength + 4], string, kParamLength);

    write(payload, kHeaderLength + kPayloadLength + kPaddingLength);
  }
}
